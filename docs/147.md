# 卡夫卡:消费者和消费者群体

> 原文:[https://www . javatpoint . com/Apache-Kafka-consumer-and-consumer-group](https://www.javatpoint.com/apache-kafka-consumer-and-consumer-groups)

消费者是通过主题消费或读取卡夫卡集群中的数据的人。消费者也知道应该从哪个代理读取数据。使用者以有序的方式读取每个分区内的数据。这意味着在从偏移量 0 读取数据之前，用户不应该从偏移量 1 读取数据。此外，消费者可以轻松地同时从多个代理读取数据

**例如**两个消费者即消费者 1 和消费者 2 正在读取数据。消费者 1 正在按顺序从代理 1 读取数据。另一方面，消费者 2 同时按顺序从代理 2 和代理 3 读取数据。

![Kafka Consumer and Consumer Groups](../Images/9b072403b2df0028ca1799f848e0691d.png)

#### 注意:消费者 2 正在从代理 2 和代理 3 并行读取数据。因此，代理 2 下的偏移量 2 与代理 3 下的偏移量 2 中包含的数据没有任何联系。

## 消费者群体

一个消费者群体是一个由多个消费者组成的群体，他们基本上关注一个应用程序。组中的每个使用者直接从独占分区中读取数据。在这种情况下，消费者的数量多于分区的数量，一些消费者将处于非活动状态。不知何故，如果我们失去了组中任何活动的消费者，那么非活动的消费者可以接管并进入活动状态来读取数据。

但是，如何决定哪个消费者应该首先读取数据，从哪个分区读取数据呢？

对于这样的决定，一个组内的消费者自动使用一个“**组协调器**”和一个“**消费者协调器**”，后者将消费者分配给一个分区。这个特性已经在卡夫卡中实现了。因此，用户无需担心。

让我们看看下面的例子。

**例 1**

考虑两组消费者，即消费者组 1 和消费者组 2。组 1 的两个使用者一起读取数据，但读取的数据来自不同的分区。组 1 的两个消费者都将保持活动状态，因为他们正在并行读取数据。

![Kafka Consumer and Consumer Groups](../Images/ceccf4976f1ed26822e7d2e9225c774b.png)

另一方面，组 2 的消费者 1 也正在从主题 t 下的分区 1 读取数据。这里，消费者也处于活动状态，因为它属于组 2。

**例 2**

考虑另一个场景，其中一个消费者组有三个消费者。消费者 1 和消费者 2 处于活动状态。使用者 1 正在从分区 0 读取数据，使用者 2 正在从分区 1 读取数据。因为，只有两个主题分区可用，但是有三个使用者。因此，消费者 3 将保持在非活动状态，直到任何活动消费者离开。

![Kafka Consumer and Consumer Groups](../Images/1cb4f3ca255de797ff7cdb61ed8b53ba.png)

#### 注意:在例 2 中，三个消费者只出现在一个组中。这就是消费者 3 不活跃的原因。但是，如果消费者在另一个组中，它将处于活动状态，并且能够读取数据。

## 消费者补偿

Apache Kafka 提供了一个方便的功能来存储消费群体的偏移值。它存储一个偏移值，以知道消费组在哪个分区读取数据。一旦组中的消费者读取数据，卡夫卡就会自动提交偏移量，或者可以对其进行编程。这些补偿在名为**_ _ consumer _ offset**的主题中实时提交。此功能是在机器出现故障，消费者无法读取数据的情况下实现的。因此，由于补偿的作用，消费者将能够从停止的地方继续阅读。

**例如**

下图中，一个消费群体的消费者正在读取数据。读取数据后，消费者已经提交了偏移量。这意味着下一次，消费者将不是从开始而是从提交点读取数据。此外，不知何故，消费者死了，它将只能继续从承诺的状态。

![Kafka Consumer and Consumer Groups](../Images/7149187fb5c938742abda16210eb6642.png)

## 传递语义

承诺的选择取决于消费者，即消费者希望何时承诺补偿。提交偏移量就像一个书签，读者在阅读一本书或一本小说时会用到它。

在卡夫卡中，使用了以下三种传递语义:

*   **最多一次:**这里，一旦消费者收到消息，就提交偏移量..但是如果处理不正确，信息就会丢失，消费者就无法进一步阅读。因此，这个语义是最不可取的。
*   **至少一次:**这里，偏移是在处理完消息后提交的。如果处理出错，消费者将再次读取该消息。因此，这通常是首选使用。因为消费者可以阅读两次消息，所以会导致消息的重复处理。因此，它需要一个系统是幂等系统。
*   **正好一次:**这里，只使用卡夫卡流应用编程接口就可以实现卡夫卡到卡夫卡工作流的偏移。为了实现卡夫卡对外部系统的抵消，我们需要使用幂等消费者。

* * *